package oberon;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Oberon.grammar".
 */
public class OberonParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short SEMICOLON = 2;
		static public final short END = 3;
		static public final short RPAREN = 4;
		static public final short OP_PLUS = 5;
		static public final short OP_MINUS = 6;
		static public final short IF = 7;
		static public final short WHILE = 8;
		static public final short LPAREN = 9;
		static public final short COLON = 10;
		static public final short COMMA = 11;
		static public final short ARRAY = 12;
		static public final short RECORD = 13;
		static public final short DOT = 14;
		static public final short NUMBER = 15;
		static public final short TILDE = 16;
		static public final short EQUALS = 17;
		static public final short LBRACE = 18;
		static public final short VAR = 19;
		static public final short THEN = 20;
		static public final short ELSEIF = 21;
		static public final short PROCEDURE = 22;
		static public final short OP_TIMES = 23;
		static public final short OP_DIV = 24;
		static public final short OP_MOD = 25;
		static public final short OP_AND = 26;
		static public final short OP_OR = 27;
		static public final short BEGIN = 28;
		static public final short CONST = 29;
		static public final short MODULE = 30;
		static public final short DO = 31;
		static public final short RBRACE = 32;
		static public final short ASSIGN = 33;
		static public final short OF = 34;
		static public final short HASHTAG = 35;
		static public final short SMALLER = 36;
		static public final short SMALLEREQ = 37;
		static public final short GREATER = 38;
		static public final short GREATEREQ = 39;
		static public final short ELSE = 40;
		static public final short TYPE = 41;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orbtUOLSKPnjzpzfAug1IL91iaYOaQ0IC20jAn8DtGf4fVTe6bTnQfIvCYlIXDfOE27H4" +
		"KKH0GKKGHn1WZAIenpHYJcFBvczcvw#LcWuz$UC$pplkrAMVEpDnlf6Y7BjPbkbJbz1rzLz" +
		"$JHMbwdpIzVve#A4qVcQRFqYNdw2trOrLGRNLIMzKBykMgfXRwgIRfHNrVLTHAj#ldQgqsc" +
		"g1sQg0c#fdoiLTLVTsaMtIh6kisx5TYUq5NsGlUNaTriOqlyZjRPLKgwgKMlHHA3NKzDGlb" +
		"RbgjLJfCpOwwG$qq9lHIwEqLE2$mS4qDqW8zeATq5DmTB5kKfT7Kpz9AzL1F3L3ioxLws1R" +
		"fSVr0Fz8YbR2#ccBzzQIUy3Zewrz1$QPgfj8gfHywoOxxzydIABsaBkgi2trRMPgh#xH2pP" +
		"KHzEOWcvcxo#iESsmbjWcsGXlql8Pustfjr2RqlM2p7j99xTEsO7EwmzDUF#9BftyBNtize" +
		"kqwuMrkF3Tej$VLrEkgg9Awcg$s4wHh#K9zTOtA4$4C64l4CU3g07l5ZcXSKjETF4dFN1NO" +
		"VA$bQfcMCblBRI5lS9ZvTTQ4NjKCFMOFWWViOJshcRfV#pLR##mXj6$h0ijLflLJ6SjHMHq" +
		"2rwcwQgYHRjQDwc2lsylggkxqcMFxrDkUqq0Dqs0mLAzfeYRRB8tG0KtJOatNOfkjUJR7xj" +
		"OzFFTgePPejitJVBl7bccDTjboMw07jKvRjKixz2ZbJjkcFNhExaFUfPVrYjxWEQwtz2PZg" +
		"S9ggyhQgywyrFY6zRAizyhXQzGjaXlvFU7sL6D5VAyhTPN$SXtvJfcizPkPcuYTLbfb$1xD" +
		"OXTciZCYTcLFLfgpbs0zP39ZIR#pTMUTf$QIb5mlINaW9qHDQhgTSGqxgx2Nf3UTMnL93Qd" +
		"L5dGeiaIS0$KfMxAZ#Uhi9rV6x804wANUd1YjM2j3675xzhB3YABwRlovxEzHNahuCkAKcC" +
		"O9byq9vDgAM1FZsKdbaGfr9tNoC#TqXwbO8cOkGTbCETvMYtLM6xqfSETd6ywxfCtf3eLwO" +
		"UdqaVWosPbvmUR6KuhJrVakuPofmrfqNwq1alj2dP6k828VT26Y0BWwXM#JO8KdjGjvad86" +
		"wppsqZZEqed8cNxaDPbVPuqrcRCZ9iwX93KlPtwdS9vTwhKCOaMF6SozYsaBtAwCQAKEvrd" +
		"2F$LuN6m69tq6vrSvodBCRKMYtUFE$mpE$mZ4VAKCtwvh8wQiG5dMnxNmjWIZAycP617LZB" +
		"8aJrCV7tajzjp6rv9EJPR$pGUdfQWLQ82y4xuJz03jGI$G4$jwk3V8BgmNvOJwcnp$Fn1t0" +
		"IY1q2F4NvtYAnriJS3U8EyFt2xmJO7R1EuMwcQbj5C#y8305S7jvnbJPT0lj9T$ll5$7V0x" +
		"IBjveO#1u3em25G9jkj1$vHnL0Dz48x2VU7kyF3W6q5n0Xu5Qe8kwE$2OuC$D$2DO332Usd" +
		"lU0SO2eO4VLZW2O4dWf5W4gW7fe3fO0QOIS17yAmGEoVmtC1JGNqmBwK$rb7K42m0Yp1y2C" +
		"y6Yy4IzEtmKj0un3SBl0miHFZuV#SpQWho4JuD#YhG6gmCUjl0QzFgBQVuBCWjmGeGrbEqB" +
		"YrsVPg#8V36m6ie$WjlIelR4dXhuDNW8h3jt3XLIv47W1Nfx#bWPiT3JDWdKOMWnyN5fxGP" +
		"K$SaV5dGswNubWS#eozjxmJ#872PmE#7ViDQLOsKTwsIrcUJhnXJovIwrSyN#tN0hrIQFZZ" +
		"qKJFeRP5hfVXxEMP#ED$85gKZgVMndmbnVOD#DcNSjOAlV$1zajRtCV0szhy7VKanusqU#7" +
		"YwZtgVfyI5ipIgdVvkQUqTIf6xfVd2zuzQ1BuuS7RmxowclJ613mJE1Hk#z4STWhr$QhrWE" +
		"nfuUuZjcXvJ71JM1l7bKcp7YebBxg#kARRJQJ6d57usKoa$smCUjqVjCNl2zjWZzepjjbts" +
		"jEsqf#m$TjZEsXlshhrZlq1wazZVsM$ij$O1qY$j4$kp$SN#YlmdOlzX$x9$6$lVFhUpbF#" +
		"qZ#pNTiPzTwz$1lvcVxG$sCVsU$lKthTVsNlsePssj#sKdRItx8GTj4C#zbZH#8vw$JLxrV" +
		"CUs##jpuUHdmtyhBre1qB4Ndl9dhJfLc2JR89DD2R01XJxtZDid8sniPOVMhhBnglOdt4os" +
		"z8WtsjhRBMjSZNGjjXcp$U3TRRPrjf6s#Gj6q8yfxbjjHss7bvYKsog3R8y6sY3Wt#e3R5f" +
		"DiA6sN0R6MoZZVyoRc6Do48QaOMqGsk7xBBUkkXroLlg#3mf0eLoT#JkCDa8YCZbOhAwcBm" +
		"kEWULy5U2Uth4vE3oUNXbshaMThWr1RSGGsO38ZBac1muAXQZy5LLWXoStO8#blRgWJx8VV" +
		"1bOyz67eti$i7x8bV3dmFdOEk4hHDoPxWpN9syzpRQ6uVl1Z99CW8GSHk9k8#SYroFcDnR8" +
		"EBE4fCfnUIw4OZb$XdpVKuQa#V5PCC9CdU1YBm#8e$Fu1ydylVfFEnvoBM9QOPU2pa9$hM1" +
		"knyaoE458dBU3BBAc5j816Bk8W8HMNvCDYmGaTsxB9cJ2da8TLq#t14RcO6$RxYCfGlS5Uu" +
		"A3$M8kJF9tvjQKQSr6ERl3p4t1FbRGWVaDjY78mz7Bi1UW3pPvz49xYOHYBc124HatJ7tZ5" +
		"XkdRdRmGnk5jFHPtu1mkaYbW==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};
 

	public final static class Events extends Parser.Events{
		public void syntaxError(Symbol token){
			throw new RuntimeException(token.value.toString());
		}
	}

	private final Action[] actions;

	public OberonParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$selector2 = selector2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$selector2 = lst$selector2 selector2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$selector2 = 
			Action.RETURN,	// [3] opt$lst$selector2 = lst$selector2
			Action.RETURN,	// [4] selector = opt$lst$selector2
			RETURN2,	// [5] selector2 = DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [6] selector2 = LBRACE expression RBRACE; returns 'RBRACE' although none is marked
			RETURN2,	// [7] factor = IDENTIFIER selector; returns 'selector' although none is marked
			Action.RETURN,	// [8] factor = NUMBER
			RETURN3,	// [9] factor = LPAREN expression RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [10] factor = TILDE factor; returns 'factor' although none is marked
			new Action() {	// [11] lst$term2 = term2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [12] lst$term2 = lst$term2 term2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [13] opt$lst$term2 = 
			Action.RETURN,	// [14] opt$lst$term2 = lst$term2
			RETURN2,	// [15] term = factor opt$lst$term2; returns 'opt$lst$term2' although none is marked
			RETURN2,	// [16] term2 = term3 factor; returns 'factor' although none is marked
			Action.RETURN,	// [17] term3 = OP_TIMES
			Action.RETURN,	// [18] term3 = OP_DIV
			Action.RETURN,	// [19] term3 = OP_MOD
			Action.RETURN,	// [20] term3 = OP_AND
			Action.NONE,  	// [21] opt$SimpleExpression2 = 
			Action.RETURN,	// [22] opt$SimpleExpression2 = SimpleExpression2
			new Action() {	// [23] lst$SimpleExpression4 = SimpleExpression4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [24] lst$SimpleExpression4 = lst$SimpleExpression4 SimpleExpression4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [25] opt$lst$SimpleExpression4 = 
			Action.RETURN,	// [26] opt$lst$SimpleExpression4 = lst$SimpleExpression4
			RETURN3,	// [27] SimpleExpression = opt$SimpleExpression2 term opt$lst$SimpleExpression4; returns 'opt$lst$SimpleExpression4' although none is marked
			Action.RETURN,	// [28] SimpleExpression2 = OP_PLUS
			Action.RETURN,	// [29] SimpleExpression2 = OP_MINUS
			Action.RETURN,	// [30] SimpleExpression3 = OP_PLUS
			Action.RETURN,	// [31] SimpleExpression3 = OP_MINUS
			Action.RETURN,	// [32] SimpleExpression3 = OP_OR
			RETURN2,	// [33] SimpleExpression4 = SimpleExpression3 term; returns 'term' although none is marked
			Action.NONE,  	// [34] opt$expression3 = 
			Action.RETURN,	// [35] opt$expression3 = expression3
			RETURN2,	// [36] expression = SimpleExpression opt$expression3; returns 'opt$expression3' although none is marked
			Action.RETURN,	// [37] expression2 = EQUALS
			Action.RETURN,	// [38] expression2 = HASHTAG
			Action.RETURN,	// [39] expression2 = SMALLER
			Action.RETURN,	// [40] expression2 = SMALLEREQ
			Action.RETURN,	// [41] expression2 = GREATER
			Action.RETURN,	// [42] expression2 = GREATEREQ
			RETURN2,	// [43] expression3 = expression2 SimpleExpression; returns 'SimpleExpression' although none is marked
			RETURN4,	// [44] assignment = IDENTIFIER selector ASSIGN expression; returns 'expression' although none is marked
			Action.NONE,  	// [45] opt$ActualParameters3 = 
			Action.RETURN,	// [46] opt$ActualParameters3 = ActualParameters3
			RETURN3,	// [47] ActualParameters = LPAREN opt$ActualParameters3 RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [48] ActualParameters2 = COMMA expression ActualParameters2; returns 'ActualParameters2' although none is marked
			new Action() {	// [49] lst$ActualParameters2 = ActualParameters2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [50] lst$ActualParameters2 = lst$ActualParameters2 ActualParameters2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [51] opt$lst$ActualParameters2 = 
			Action.RETURN,	// [52] opt$lst$ActualParameters2 = lst$ActualParameters2
			RETURN2,	// [53] ActualParameters3 = expression opt$lst$ActualParameters2; returns 'opt$lst$ActualParameters2' although none is marked
			Action.NONE,  	// [54] opt$ActualParameters = 
			Action.RETURN,	// [55] opt$ActualParameters = ActualParameters
			RETURN3,	// [56] ProcedureCall = IDENTIFIER selector opt$ActualParameters; returns 'opt$ActualParameters' although none is marked
			new Action() {	// [57] lst$IfStatement2 = IfStatement2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [58] lst$IfStatement2 = lst$IfStatement2 IfStatement2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [59] opt$lst$IfStatement2 = 
			Action.RETURN,	// [60] opt$lst$IfStatement2 = lst$IfStatement2
			Action.NONE,  	// [61] opt$IfStatement3 = 
			Action.RETURN,	// [62] opt$IfStatement3 = IfStatement3
			RETURN7,	// [63] IfStatement = IF expression THEN StatementSequence opt$lst$IfStatement2 opt$IfStatement3 END; returns 'END' although none is marked
			RETURN4,	// [64] IfStatement2 = ELSEIF expression THEN StatementSequence; returns 'StatementSequence' although none is marked
			RETURN2,	// [65] IfStatement3 = ELSE StatementSequence; returns 'StatementSequence' although none is marked
			RETURN5,	// [66] WhileStatement = WHILE expression DO StatementSequence END; returns 'END' although none is marked
			Action.NONE,  	// [67] opt$statement2 = 
			Action.RETURN,	// [68] opt$statement2 = statement2
			Action.RETURN,	// [69] statement = opt$statement2
			Action.RETURN,	// [70] statement2 = assignment
			Action.RETURN,	// [71] statement2 = ProcedureCall
			Action.RETURN,	// [72] statement2 = IfStatement
			Action.RETURN,	// [73] statement2 = WhileStatement
			new Action() {	// [74] lst$StatementSequence2 = StatementSequence2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [75] lst$StatementSequence2 = lst$StatementSequence2 StatementSequence2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [76] opt$lst$StatementSequence2 = 
			Action.RETURN,	// [77] opt$lst$StatementSequence2 = lst$StatementSequence2
			RETURN2,	// [78] StatementSequence = statement opt$lst$StatementSequence2; returns 'opt$lst$StatementSequence2' although none is marked
			RETURN2,	// [79] StatementSequence2 = SEMICOLON statement; returns 'statement' although none is marked
			new Action() {	// [80] lst$IdentList2 = IdentList2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [81] lst$IdentList2 = lst$IdentList2 IdentList2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [82] opt$lst$IdentList2 = 
			Action.RETURN,	// [83] opt$lst$IdentList2 = lst$IdentList2
			RETURN2,	// [84] IdentList = IDENTIFIER opt$lst$IdentList2; returns 'opt$lst$IdentList2' although none is marked
			RETURN2,	// [85] IdentList2 = COMMA IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN4,	// [86] ArrayType = ARRAY expression OF type; returns 'type' although none is marked
			Action.NONE,  	// [87] opt$FieldList2 = 
			Action.RETURN,	// [88] opt$FieldList2 = FieldList2
			Action.RETURN,	// [89] FieldList = opt$FieldList2
			RETURN3,	// [90] FieldList2 = IdentList COLON type; returns 'type' although none is marked
			new Action() {	// [91] lst$RecordType2 = RecordType2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [92] lst$RecordType2 = lst$RecordType2 RecordType2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [93] opt$lst$RecordType2 = 
			Action.RETURN,	// [94] opt$lst$RecordType2 = lst$RecordType2
			RETURN4,	// [95] RecordType = RECORD FieldList opt$lst$RecordType2 END; returns 'END' although none is marked
			RETURN2,	// [96] RecordType2 = SEMICOLON FieldList; returns 'FieldList' although none is marked
			Action.RETURN,	// [97] type = IDENTIFIER
			Action.RETURN,	// [98] type = ArrayType
			Action.RETURN,	// [99] type = RecordType
			Action.NONE,  	// [100] opt$VAR = 
			Action.RETURN,	// [101] opt$VAR = VAR
			RETURN4,	// [102] FPSection = opt$VAR IdentList COLON type; returns 'type' although none is marked
			Action.NONE,  	// [103] opt$FormalParameters3 = 
			Action.RETURN,	// [104] opt$FormalParameters3 = FormalParameters3
			RETURN3,	// [105] FormalParameters = LPAREN opt$FormalParameters3 RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [106] FormalParameters2 = SEMICOLON FPSection; returns 'FPSection' although none is marked
			new Action() {	// [107] lst$FormalParameters2 = FormalParameters2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [108] lst$FormalParameters2 = lst$FormalParameters2 FormalParameters2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [109] opt$lst$FormalParameters2 = 
			Action.RETURN,	// [110] opt$lst$FormalParameters2 = lst$FormalParameters2
			RETURN2,	// [111] FormalParameters3 = FPSection opt$lst$FormalParameters2; returns 'opt$lst$FormalParameters2' although none is marked
			Action.NONE,  	// [112] opt$FormalParameters = 
			Action.RETURN,	// [113] opt$FormalParameters = FormalParameters
			RETURN3,	// [114] ProcedureHeading = PROCEDURE IDENTIFIER opt$FormalParameters; returns 'opt$FormalParameters' although none is marked
			Action.NONE,  	// [115] opt$ProcedureBody2 = 
			Action.RETURN,	// [116] opt$ProcedureBody2 = ProcedureBody2
			RETURN4,	// [117] ProcedureBody = declarations opt$ProcedureBody2 END IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [118] ProcedureBody2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
			RETURN3,	// [119] ProcedureDeclaration = ProcedureHeading SEMICOLON ProcedureBody; returns 'ProcedureBody' although none is marked
			Action.NONE,  	// [120] opt$declarations3 = 
			Action.RETURN,	// [121] opt$declarations3 = declarations3
			Action.NONE,  	// [122] opt$declarations5 = 
			Action.RETURN,	// [123] opt$declarations5 = declarations5
			Action.NONE,  	// [124] opt$declarations7 = 
			Action.RETURN,	// [125] opt$declarations7 = declarations7
			new Action() {	// [126] lst$declarations8 = declarations8
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [127] lst$declarations8 = lst$declarations8 declarations8
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [128] opt$lst$declarations8 = 
			Action.RETURN,	// [129] opt$lst$declarations8 = lst$declarations8
			RETURN4,	// [130] declarations = opt$declarations3 opt$declarations5 opt$declarations7 opt$lst$declarations8; returns 'opt$lst$declarations8' although none is marked
			RETURN4,	// [131] declarations2 = IDENTIFIER EQUALS expression SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [132] lst$declarations2 = declarations2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [133] lst$declarations2 = lst$declarations2 declarations2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [134] opt$lst$declarations2 = 
			Action.RETURN,	// [135] opt$lst$declarations2 = lst$declarations2
			RETURN2,	// [136] declarations3 = CONST opt$lst$declarations2; returns 'opt$lst$declarations2' although none is marked
			RETURN4,	// [137] declarations4 = IDENTIFIER EQUALS type SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [138] lst$declarations4 = declarations4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [139] lst$declarations4 = lst$declarations4 declarations4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [140] opt$lst$declarations4 = 
			Action.RETURN,	// [141] opt$lst$declarations4 = lst$declarations4
			RETURN2,	// [142] declarations5 = TYPE opt$lst$declarations4; returns 'opt$lst$declarations4' although none is marked
			RETURN4,	// [143] declarations6 = IdentList COLON type SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [144] lst$declarations6 = declarations6
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [145] lst$declarations6 = lst$declarations6 declarations6
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [146] opt$lst$declarations6 = 
			Action.RETURN,	// [147] opt$lst$declarations6 = lst$declarations6
			RETURN2,	// [148] declarations7 = VAR opt$lst$declarations6; returns 'opt$lst$declarations6' although none is marked
			RETURN2,	// [149] declarations8 = ProcedureDeclaration SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.NONE,  	// [150] opt$module2 = 
			Action.RETURN,	// [151] opt$module2 = module2
			RETURN8,	// [152] module = MODULE IDENTIFIER SEMICOLON declarations opt$module2 END IDENTIFIER DOT; returns 'DOT' although none is marked
			RETURN2	// [153] module2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
		};

 		report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
