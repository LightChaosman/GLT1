package oberon;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Oberon.grammar".
 */
public class OberonParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short SEMICOLON = 2;
		static public final short END = 3;
		static public final short RPAREN = 4;
		static public final short OP_PLUS = 5;
		static public final short OP_MINUS = 6;
		static public final short IF = 7;
		static public final short WHILE = 8;
		static public final short LPAREN = 9;
		static public final short COLON = 10;
		static public final short ARRAY = 11;
		static public final short RECORD = 12;
		static public final short DOT = 13;
		static public final short COMMA = 14;
		static public final short NUMBER = 15;
		static public final short TILDE = 16;
		static public final short EQUALS = 17;
		static public final short LBRACE = 18;
		static public final short VAR = 19;
		static public final short THEN = 20;
		static public final short ELSEIF = 21;
		static public final short PROCEDURE = 22;
		static public final short OP_TIMES = 23;
		static public final short OP_DIV = 24;
		static public final short OP_MOD = 25;
		static public final short OP_AND = 26;
		static public final short OP_OR = 27;
		static public final short BEGIN = 28;
		static public final short CONST = 29;
		static public final short MODULE = 30;
		static public final short DO = 31;
		static public final short RBRACE = 32;
		static public final short ASSIGN = 33;
		static public final short OF = 34;
		static public final short HASHTAG = 35;
		static public final short SMALLER = 36;
		static public final short SMALLEREQ = 37;
		static public final short GREATER = 38;
		static public final short GREATEREQ = 39;
		static public final short ELSE = 40;
		static public final short TYPE = 41;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orbtUOLSKPnjzpxnA311GK8ma6q614P05f0akLfGWelHXwPtS1OUbbQRiqwT8xk22eA3Q" +
		"AegAeeA0eA2GcCH5ZJ329qNHJllncTYxStApcyG$FVTxpVctcp9tvPivtf6YlIkjgNQNoka" +
		"RVrhNwLee#A4KVaQBdfEYvAVfybVillOEkrtLgg5vghnye0wqAsgsggo7AqulwZkghe#xKN" +
		"UgapfeUeYjgYchgATNMzzL6DLHLCJN5ShjQALEjrKGjD0pB14sreNeOZxCal1budjGJFAMw" +
		"RlQUMg7V1e6RqQAdkkiAbT4adXAdHP6dhoRw5aNQWC1PWSTg6wEQ7RHbWNThWOxJReDULmN" +
		"r0stLJe#hlqPwV4#LlQM46vMTLYCrrYoYnjFkfEvGce#ge4gwMxsr0akH$e8MQZ3ylDVNQw" +
		"tdF4rJeMt4FjhMwJczmgmv#mDwIFThftRfNXNghBwf8zgaZVg6NjQZsklz3tf$eHRfG95a8" +
		"$MqBbStxttDsvnKg2vwKszxlQGE#H4xk#DIggRlQh9kq2brrOsiQZNTmXhTn9hMTH5saZMj" +
		"xwKJzg9lCqTzF3juoJRQOi$Bj4L7RQKAj5ghj0PjcwrWDbta4JrcEy1s6svxDLppj5M7TPa" +
		"zR2DicCeYbzMLIbSTrTDjQgwMEgOUzfQzfX$g7WtLG7l1dbEsHg6DqHjQgN6QePbwoHOmit" +
		"FHy#rUMwGbjb1Bj5XBjLptQRCjiQNQRckqJWTjhItN7XtK8zh7$HazgntQRnlmF8H#Mg$g1" +
		"FUtz8xEC9AQP5fjyguECr7lQzRBajlL$Sot9FCR1wqP#x6ttq#js8ati7#g#ZNgUJ6wZo9M" +
		"fokPtfmy7q1sbiJYzce5TkCLpEWKB6sOitbaOkGj2MzZFDtODyt8ylxUq#fYlmcEs0cJMAq" +
		"HP7DNj98NFHc#HMfyWflwao3LsWDh1gV8B7hA12N8vpjq6TdjC93pobaw#b6bUNaCKQrfru" +
		"KiZVceY7DYCETD9on5UdlsRI#udTUdiOCSkrcB$6yOVRNbRElfxQKu9HkGOMx$HvnI4UTR3" +
		"barNlcS3Db9$eXCJqXnzcG1$$wIrqaHUJakwAKrrO$OsHrN9EkhaBjDoCt9VbKR#JLgGcHf" +
		"7v76cfOBKjppQ4umnmv5KXGyCNwpYPj9pkSn3dU2fZ6RpdSLMjn3xFwRU787MiUHuzvU1hJ" +
		"nUp3Yx4f3wiBT$J8vsUESy2wk4YZFN5VZhB$QFy$rUntMQ$meOluUCUzblTpUnzG7QMYkj#" +
		"jzH3lkRS7b$2BFHVUOd#qOhQLpi#Il9c0XE0OEIL4Qw8lyHxWKk1lqHty47W065RMBXeJs#" +
		"nn$4RZg4nk1ya6$yP8lgX1iNS7U8EyFt2Tmcy0z0eyCRIidzLCbSC9tCsZ$nMEAQe8HeRyv" +
		"NpR#hmAkm$IR7PwH0sg0KU3MOAkJD8O6O232KRWVg0l61bykjnFmUD0Gz4O$0qyC$g61Cq2" +
		"MmbeczSryHgF1yA2F2JmZS1uO1b2Z5c0sA03pG3u17y3pG#o2m8i2JmVDmUAavoq5cM0PM8" +
		"xXFBm2h0JtWTPW5UWOubi6NWtM8Bp$ltCPtGac8NmQzFMW6rWNz90FqQQKTcj1GkuCDe2UG" +
		"T#I4hizHTyHk33mPb02x4g9snbuT#2DW3qLxKcECxFpbzfm#alvgVypn9qECPL2VvM37Yik" +
		"FgbFTzgmBrKrwBsIV8dzzX7zVnxa3mD$4lZQm1V2SzE3NZ$flwQdFBFp$nbJzwIsTRuizgk" +
		"0gqoAdjXdDO8#ACddpm7#zxlGJFZZvBQ9TU4Q5VGBIMEk5tnZW##pbEUcW#FO$nhqbSMCjL" +
		"lWawc#n5e4$wpmp8mas#HY#ZkL90zCyINsPMRWSe7x1l#1OlgR7lXOu4fW#IL$r3NOiuffU" +
		"pBmrX3R8pMcE71D2F4LasndYubBxC7UIRRtKcBEALmsNqcNSVxQ4$QOFMvFsc7RPq$RCtR8" +
		"3je1ss$$ibVjWfsndzbFxAT8RnFxA$kbVMWV8RrddzaVx5FZhMUV4Fit#uVzq$wDzhbTuFv" +
		"t#urzOEVTkdlzB#3FzdlxdVtMFhO$sVls2$kv$ThUjH$RZ#oSdRLtx9WTzx5lNXpVwpptbB" +
		"tXhOVj9Myx4iPz8V2pTjHU3X7Fsolsb1NON9jfCopF#FkMLUo$dcTJR99DjgcXf#asJSLUn" +
		"dbiguEythROPjlaMg3jiTsUju7xRRTjjLtsWBVi3F6SDVQWFMg5y2gRRNDib6LRZeqE$dji" +
		"ZELRhesrSJO#s2RQ16W35Mu4OlvTxwhOLg0nUcDEiKPm8$H6GUw7t0zsTKT$v2R8pK4Bv6J" +
		"mdWSHDRT3JAvkwOjSdNvkWHrkJq9BOjmxTo1o3UH1S76OWA#sqkJUFvFG9zDV9hR1o8FX8T" +
		"Y7#BeyHlKf4F4D4QVATPLkZ4fOlXfsx#tUS1sgtjRqDmLVNUh5MjXhOKy7DLCmt2D6jIyGy" +
		"PNYAiSOjMy4ObIu0f6l#jg2s#YtExRksDpNHJV6aGLduSl6detSa9Xsw0sG4sYAhodS0H$l" +
		"T11HryPzJPc3d0DJku28UZv6nIiGKTF7vTPxDF8OkMeuHbKVvvj28E8RHI2YwXQ8UEyvnFX" +
		"AalzIwaYRJi1L$cEnpy4#1xa7ScViuv378S$5FjU$ocE#Liv5paLszKa#ycpaku3Bi$7ey$" +
		"YkA42V$n$CLoGZ");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};
 

	public final static class Events extends Parser.Events{
		public void syntaxError(Symbol token){
			throw new RuntimeException(token.value.toString());
		}
	}

	private final Action[] actions;

	public OberonParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$selector2 = selector2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$selector2 = lst$selector2 selector2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$selector2 = 
			Action.RETURN,	// [3] opt$lst$selector2 = lst$selector2
			Action.RETURN,	// [4] selector = opt$lst$selector2
			RETURN2,	// [5] selector2 = DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [6] selector2 = LBRACE expression RBRACE; returns 'RBRACE' although none is marked
			RETURN2,	// [7] factor = IDENTIFIER selector; returns 'selector' although none is marked
			Action.RETURN,	// [8] factor = NUMBER
			RETURN3,	// [9] factor = LPAREN expression RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [10] factor = TILDE factor; returns 'factor' although none is marked
			new Action() {	// [11] lst$term2 = term2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [12] lst$term2 = lst$term2 term2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [13] opt$lst$term2 = 
			Action.RETURN,	// [14] opt$lst$term2 = lst$term2
			RETURN2,	// [15] term = factor opt$lst$term2; returns 'opt$lst$term2' although none is marked
			RETURN2,	// [16] term2 = term3 factor; returns 'factor' although none is marked
			Action.RETURN,	// [17] term3 = OP_TIMES
			Action.RETURN,	// [18] term3 = OP_DIV
			Action.RETURN,	// [19] term3 = OP_MOD
			Action.RETURN,	// [20] term3 = OP_AND
			Action.NONE,  	// [21] opt$SimpleExpression2 = 
			Action.RETURN,	// [22] opt$SimpleExpression2 = SimpleExpression2
			new Action() {	// [23] lst$SimpleExpression4 = SimpleExpression4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [24] lst$SimpleExpression4 = lst$SimpleExpression4 SimpleExpression4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [25] opt$lst$SimpleExpression4 = 
			Action.RETURN,	// [26] opt$lst$SimpleExpression4 = lst$SimpleExpression4
			RETURN3,	// [27] SimpleExpression = opt$SimpleExpression2 term opt$lst$SimpleExpression4; returns 'opt$lst$SimpleExpression4' although none is marked
			Action.RETURN,	// [28] SimpleExpression2 = OP_PLUS
			Action.RETURN,	// [29] SimpleExpression2 = OP_MINUS
			Action.RETURN,	// [30] SimpleExpression3 = OP_PLUS
			Action.RETURN,	// [31] SimpleExpression3 = OP_MINUS
			Action.RETURN,	// [32] SimpleExpression3 = OP_OR
			RETURN2,	// [33] SimpleExpression4 = SimpleExpression3 term; returns 'term' although none is marked
			Action.NONE,  	// [34] opt$expression3 = 
			Action.RETURN,	// [35] opt$expression3 = expression3
			RETURN2,	// [36] expression = SimpleExpression opt$expression3; returns 'opt$expression3' although none is marked
			Action.RETURN,	// [37] expression2 = EQUALS
			Action.RETURN,	// [38] expression2 = HASHTAG
			Action.RETURN,	// [39] expression2 = SMALLER
			Action.RETURN,	// [40] expression2 = SMALLEREQ
			Action.RETURN,	// [41] expression2 = GREATER
			Action.RETURN,	// [42] expression2 = GREATEREQ
			RETURN2,	// [43] expression3 = expression2 SimpleExpression; returns 'SimpleExpression' although none is marked
			RETURN4,	// [44] assignment = IDENTIFIER selector ASSIGN expression; returns 'expression' although none is marked
			Action.NONE,  	// [45] opt$ActualParameters3 = 
			Action.RETURN,	// [46] opt$ActualParameters3 = ActualParameters3
			RETURN3,	// [47] ActualParameters = LPAREN opt$ActualParameters3 RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [48] ActualParameters2 = COMMA expression; returns 'expression' although none is marked
			new Action() {	// [49] lst$ActualParameters2 = ActualParameters2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [50] lst$ActualParameters2 = lst$ActualParameters2 ActualParameters2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [51] opt$lst$ActualParameters2 = 
			Action.RETURN,	// [52] opt$lst$ActualParameters2 = lst$ActualParameters2
			RETURN2,	// [53] ActualParameters3 = expression opt$lst$ActualParameters2; returns 'opt$lst$ActualParameters2' although none is marked
			Action.NONE,  	// [54] opt$ActualParameters = 
			Action.RETURN,	// [55] opt$ActualParameters = ActualParameters
			RETURN3,	// [56] ProcedureCall = IDENTIFIER selector opt$ActualParameters; returns 'opt$ActualParameters' although none is marked
			new Action() {	// [57] lst$IfStatement2 = IfStatement2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [58] lst$IfStatement2 = lst$IfStatement2 IfStatement2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [59] opt$lst$IfStatement2 = 
			Action.RETURN,	// [60] opt$lst$IfStatement2 = lst$IfStatement2
			Action.NONE,  	// [61] opt$IfStatement3 = 
			Action.RETURN,	// [62] opt$IfStatement3 = IfStatement3
			RETURN7,	// [63] IfStatement = IF expression THEN StatementSequence opt$lst$IfStatement2 opt$IfStatement3 END; returns 'END' although none is marked
			RETURN4,	// [64] IfStatement2 = ELSEIF expression THEN StatementSequence; returns 'StatementSequence' although none is marked
			RETURN2,	// [65] IfStatement3 = ELSE StatementSequence; returns 'StatementSequence' although none is marked
			RETURN5,	// [66] WhileStatement = WHILE expression DO StatementSequence END; returns 'END' although none is marked
			Action.NONE,  	// [67] opt$statement2 = 
			Action.RETURN,	// [68] opt$statement2 = statement2
			Action.RETURN,	// [69] statement = opt$statement2
			Action.RETURN,	// [70] statement2 = assignment
			Action.RETURN,	// [71] statement2 = ProcedureCall
			Action.RETURN,	// [72] statement2 = IfStatement
			Action.RETURN,	// [73] statement2 = WhileStatement
			new Action() {	// [74] lst$StatementSequence2 = StatementSequence2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [75] lst$StatementSequence2 = lst$StatementSequence2 StatementSequence2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [76] opt$lst$StatementSequence2 = 
			Action.RETURN,	// [77] opt$lst$StatementSequence2 = lst$StatementSequence2
			RETURN2,	// [78] StatementSequence = statement opt$lst$StatementSequence2; returns 'opt$lst$StatementSequence2' although none is marked
			RETURN2,	// [79] StatementSequence2 = SEMICOLON statement; returns 'statement' although none is marked
			new Action() {	// [80] lst$IdentList2 = IdentList2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [81] lst$IdentList2 = lst$IdentList2 IdentList2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [82] opt$lst$IdentList2 = 
			Action.RETURN,	// [83] opt$lst$IdentList2 = lst$IdentList2
			RETURN2,	// [84] IdentList = IDENTIFIER opt$lst$IdentList2; returns 'opt$lst$IdentList2' although none is marked
			RETURN2,	// [85] IdentList2 = COMMA IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN4,	// [86] ArrayType = ARRAY expression OF type; returns 'type' although none is marked
			Action.NONE,  	// [87] opt$FieldList2 = 
			Action.RETURN,	// [88] opt$FieldList2 = FieldList2
			Action.RETURN,	// [89] FieldList = opt$FieldList2
			RETURN3,	// [90] FieldList2 = IdentList COLON type; returns 'type' although none is marked
			new Action() {	// [91] lst$RecordType2 = RecordType2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [92] lst$RecordType2 = lst$RecordType2 RecordType2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [93] opt$lst$RecordType2 = 
			Action.RETURN,	// [94] opt$lst$RecordType2 = lst$RecordType2
			RETURN4,	// [95] RecordType = RECORD FieldList opt$lst$RecordType2 END; returns 'END' although none is marked
			RETURN2,	// [96] RecordType2 = SEMICOLON FieldList; returns 'FieldList' although none is marked
			Action.RETURN,	// [97] type = IDENTIFIER
			Action.RETURN,	// [98] type = ArrayType
			Action.RETURN,	// [99] type = RecordType
			Action.NONE,  	// [100] opt$VAR = 
			Action.RETURN,	// [101] opt$VAR = VAR
			RETURN4,	// [102] FPSection = opt$VAR IdentList COLON type; returns 'type' although none is marked
			Action.NONE,  	// [103] opt$FormalParameters3 = 
			Action.RETURN,	// [104] opt$FormalParameters3 = FormalParameters3
			RETURN3,	// [105] FormalParameters = LPAREN opt$FormalParameters3 RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [106] FormalParameters2 = SEMICOLON FPSection; returns 'FPSection' although none is marked
			new Action() {	// [107] lst$FormalParameters2 = FormalParameters2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [108] lst$FormalParameters2 = lst$FormalParameters2 FormalParameters2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [109] opt$lst$FormalParameters2 = 
			Action.RETURN,	// [110] opt$lst$FormalParameters2 = lst$FormalParameters2
			RETURN2,	// [111] FormalParameters3 = FPSection opt$lst$FormalParameters2; returns 'opt$lst$FormalParameters2' although none is marked
			Action.NONE,  	// [112] opt$FormalParameters = 
			Action.RETURN,	// [113] opt$FormalParameters = FormalParameters
			RETURN3,	// [114] ProcedureHeading = PROCEDURE IDENTIFIER opt$FormalParameters; returns 'opt$FormalParameters' although none is marked
			Action.NONE,  	// [115] opt$ProcedureBody2 = 
			Action.RETURN,	// [116] opt$ProcedureBody2 = ProcedureBody2
			RETURN4,	// [117] ProcedureBody = declarations opt$ProcedureBody2 END IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [118] ProcedureBody2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
			RETURN3,	// [119] ProcedureDeclaration = ProcedureHeading SEMICOLON ProcedureBody; returns 'ProcedureBody' although none is marked
			Action.NONE,  	// [120] opt$declarations3 = 
			Action.RETURN,	// [121] opt$declarations3 = declarations3
			Action.NONE,  	// [122] opt$declarations5 = 
			Action.RETURN,	// [123] opt$declarations5 = declarations5
			Action.NONE,  	// [124] opt$declarations7 = 
			Action.RETURN,	// [125] opt$declarations7 = declarations7
			new Action() {	// [126] lst$declarations8 = declarations8
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [127] lst$declarations8 = lst$declarations8 declarations8
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [128] opt$lst$declarations8 = 
			Action.RETURN,	// [129] opt$lst$declarations8 = lst$declarations8
			RETURN4,	// [130] declarations = opt$declarations3 opt$declarations5 opt$declarations7 opt$lst$declarations8; returns 'opt$lst$declarations8' although none is marked
			RETURN4,	// [131] declarations2 = IDENTIFIER EQUALS expression SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [132] lst$declarations2 = declarations2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [133] lst$declarations2 = lst$declarations2 declarations2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [134] opt$lst$declarations2 = 
			Action.RETURN,	// [135] opt$lst$declarations2 = lst$declarations2
			RETURN2,	// [136] declarations3 = CONST opt$lst$declarations2; returns 'opt$lst$declarations2' although none is marked
			RETURN4,	// [137] declarations4 = IDENTIFIER EQUALS type SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [138] lst$declarations4 = declarations4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [139] lst$declarations4 = lst$declarations4 declarations4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [140] opt$lst$declarations4 = 
			Action.RETURN,	// [141] opt$lst$declarations4 = lst$declarations4
			RETURN2,	// [142] declarations5 = TYPE opt$lst$declarations4; returns 'opt$lst$declarations4' although none is marked
			RETURN4,	// [143] declarations6 = IdentList COLON type SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [144] lst$declarations6 = declarations6
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [145] lst$declarations6 = lst$declarations6 declarations6
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [146] opt$lst$declarations6 = 
			Action.RETURN,	// [147] opt$lst$declarations6 = lst$declarations6
			RETURN2,	// [148] declarations7 = VAR opt$lst$declarations6; returns 'opt$lst$declarations6' although none is marked
			RETURN2,	// [149] declarations8 = ProcedureDeclaration SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.NONE,  	// [150] opt$module2 = 
			Action.RETURN,	// [151] opt$module2 = module2
			RETURN8,	// [152] module = MODULE IDENTIFIER SEMICOLON declarations opt$module2 END IDENTIFIER DOT; returns 'DOT' although none is marked
			RETURN2	// [153] module2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
		};

 		report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
