package oberon;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Oberon.grammar".
 */
public class OberonParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short SEMICOLON = 2;
		static public final short END = 3;
		static public final short RPAREN = 4;
		static public final short OP_PLUS = 5;
		static public final short OP_MINUS = 6;
		static public final short IF = 7;
		static public final short WHILE = 8;
		static public final short COLON = 9;
		static public final short LPAREN = 10;
		static public final short ARRAY = 11;
		static public final short RECORD = 12;
		static public final short DOT = 13;
		static public final short COMMA = 14;
		static public final short NUMBER = 15;
		static public final short TILDE = 16;
		static public final short EQUALS = 17;
		static public final short LBRACE = 18;
		static public final short VAR = 19;
		static public final short THEN = 20;
		static public final short ELSEIF = 21;
		static public final short PROCEDURE = 22;
		static public final short OP_TIMES = 23;
		static public final short OP_DIV = 24;
		static public final short OP_MOD = 25;
		static public final short OP_AND = 26;
		static public final short OP_OR = 27;
		static public final short BEGIN = 28;
		static public final short CONST = 29;
		static public final short MODULE = 30;
		static public final short DO = 31;
		static public final short RBRACE = 32;
		static public final short ASSIGN = 33;
		static public final short OF = 34;
		static public final short HASHTAG = 35;
		static public final short SMALLER = 36;
		static public final short SMALLEREQ = 37;
		static public final short GREATER = 38;
		static public final short GREATEREQ = 39;
		static public final short ELSE = 40;
		static public final short TYPE = 41;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orbtUOLSKPXt$ddaiGXCK5510KDmQ51HI4NTnLM5WMLdeJ5QcAW0GmAfP4KS1UgCk288e" +
		"DHL1qfQYq22OciIQMH6EB8TqIqKHZIVBvpjpPzN2V2$ahTvvtlZBVp3bdpioSxqhH2ZLMCp" +
		"LLSnsk8zH2ZRBiCLdsn2nxSfPzVfPzXGxRp#wd0hNHgHeHP6kTg2xggfDiWRef1R7wgrAdQ" +
		"O06gZTsRnsbjYfJNy$HsA67jpEZb0RPX$YCThgAr4h3DPJuZEVCHFmvGKxLzuCsJqk2jb9h" +
		"TIl#jMgfItIysYFdw0nDKdrTwQGjKJrzHtTeY6RhRXznfMxHJUgW#tIl6lgwGCVeL7jBFTM" +
		"B$eV2aT31ZrDBIytIXTJLjjcFM#EzoxHSAtIRLkiYIhKke5IhK0$hTjzIxTk#w#i74fvDNj" +
		"$kwnxUCqXfbVWxS0pMiVeUunn7tKaTuGJYsZ5FtP4bo69x8n4Fs6CrocklrFb7QOPcsZgDr" +
		"wM#PODkqFLQQ9jjemvX5c$K3zL0MxLHYxHGDNXhVByVsMAU8KyJT9SzwR3TjbkFsY9jqNgj" +
		"juLgGibNPvsiKrIk2WspDpNIVgFHzhhEqjaQPozhYhseStMUfcYwVg2BDKsFw77DiVjqkQw" +
		"bN6RtwofxmDRgQifSpTSrkautsuEstXxH0YssH#qXUrZhj1JkX2gjqXhTOq$eGTsl3Nh8zj" +
		"WcUugMnxIP#aazeHtKsxIJ6QjTUzsOjQB$ivtFstBlgNETRC5gQSLAcgc8dH1Ht3jjnpizd" +
		"dKNmHZcgGbxpZ4HkxQ7ixD7Y#gqKrZtazWL3UiykU9xrMdzwhHYLbalweZTu7P5n6wjppg8" +
		"DJh88Rpn0Omydjf5ZFPlhpNhw7HMagipOwL3$pPG0Arz$reYTc#PV#B8ssbVzs2jbB2x6h7" +
		"FXz8oWX9n6ZGBBP5lA$TrqfFHCtLZxndBsTFKtu7ZN4wA2iPnTMzE5KTZnd7pr9Wu9zE9U4" +
		"UQtPldjRZEbyUfSnRsP8tpTeeJPnfrH7J4B3Rqv#LqJfj1U8ln5lkuDlHfnXdO7c$iQK3fB" +
		"q4UnVbIj9SooZ7qAeKqfsQ6vkotc78ujFMofuzlpfWTU3$k#aTGt2Z3VAIRrNnlkJjB#JAO" +
		"alObykzt83JWt8dHOer4ZqAT8UL76UvbFbBQDK$#rnuguKEu55P0bHIrWwEWDvo4Rm6o3$G" +
		"D$PQWLpZzGF1x1vR11y4#Bj7sKP0LS4lGtHokpZ5EXo27Gla1hlL9a9zbP7HQa34KvkuJrO" +
		"FAq6$gmPubSPqDz1aG#W#450o6#j0GkCUe4PGHK8CiXyDWPEWpYceJSZGqWLBiBSWpGti#3" +
		"4BPYUmVV2V341WMxB4mFEZZe1#S0otXF9WCKs4Q0KyXpm#nCu8S3wrW5imClWlXQBW8BiQn" +
		"1ta1p8PBe01O7z6nq0akWolWSc9tvvZRpZ0HvQLWpu4UC3VOLqC9p4$qkOhgvQ1t1zJe1YY" +
		"2Q#3cq7PhaDTHlOvqQtDHOfp5GLvBzHxIhTMgsdOpUoFnFfbNzSprhebx9SHy76JAkNF59i" +
		"RhAhz$r3ICyKMYRNwGgs1Jq7V1rXpZR0$Fa4Urym3NUYR8PxFyHGUvlv9lzQZfmPubqITlV" +
		"piw9FXxkJKVzChml6$YQu6wBTa7$zuGDoJOxoV67n5ydzAtRV0z7PYRY9kNqFi4kIVxVXdd" +
		"gyIz7fdeSqRm5IHyEn9wMTPp5WR$NlIEmHVsf9PcNvVVs23N13dAhUFazTsQpz5lNHYxM#B" +
		"QnLanNoRqZK5#dOZlasYl2Rv#mTwbyBDxbVZPy$0J#wazJ$sqFMlFsI$iv$OpUuOv$BNjix" +
		"Vjp$P7#nCQ9xdzrVxkwx$O1$Q#$Sq#jtzXVswVsJ$j7$QfVKAlh#6$UFzZ#wZ$RH$RH$QXV" +
		"UMjB#4B#uFjjT$RU$OxUzTUjTTyos$3$UohhRcZNthzL#4kzmNvGcshlMHtsnghiZkmgsnf" +
		"pcUxnrRRgj1xjTsk$$6pn#nnssfRmdtysFoysROWTzXEBxVlr#TEMsxBWhxSgkqkMsahWht" +
		"IRaFC9XyHfCXC734PGSfd1wL1BmU#hH2JpKJxKOY$4DcHjav8HqM2lhJtfMqCSWnsPyOw6v" +
		"cBYRHr9MVWMm4HcLJil$sLo4cqyLs1Y0mtTciL8dBT#cGed97aFfE9wOxiWjs5jXFWn2oAV" +
		"EuZYCbCKcGXWfXiBaqsAOZ8DIFsHan#boPVaSzPUk2hXUyPHFu$qXJqAUXJYU4x2p4vQahk" +
		"spOD$r1ile4GaSMcoTbIv9cnEviW8iSJH6Hw0fS9fyca1FN8TbC#5ngEFXqzayFL8#DBoNs" +
		"$onXd0d82$MQIqSx0F#iRbSAYDW==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};
 

	public final static class Events extends Parser.Events{
		public void syntaxError(Symbol token){
			throw new RuntimeException(token.value.toString());
		}
	}

	private final Action[] actions;

	public OberonParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.NONE,  	// [0] selector = 
			RETURN2,	// [1] selector = selector2 selector; returns 'selector' although none is marked
			RETURN2,	// [2] selector2 = DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [3] selector2 = LBRACE expression RBRACE; returns 'RBRACE' although none is marked
			RETURN2,	// [4] factor = IDENTIFIER selector; returns 'selector' although none is marked
			Action.RETURN,	// [5] factor = NUMBER
			RETURN3,	// [6] factor = LPAREN expression RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [7] factor = TILDE factor; returns 'factor' although none is marked
			RETURN2,	// [8] term = factor term2; returns 'term2' although none is marked
			Action.NONE,  	// [9] term2 = 
			RETURN3,	// [10] term2 = term3 factor term2; returns 'term2' although none is marked
			Action.RETURN,	// [11] term3 = OP_TIMES
			Action.RETURN,	// [12] term3 = OP_DIV
			Action.RETURN,	// [13] term3 = OP_MOD
			Action.RETURN,	// [14] term3 = OP_AND
			Action.NONE,  	// [15] opt$SimpleExpression2 = 
			Action.RETURN,	// [16] opt$SimpleExpression2 = SimpleExpression2
			RETURN3,	// [17] SimpleExpression = opt$SimpleExpression2 term SimpleExpression4; returns 'SimpleExpression4' although none is marked
			Action.RETURN,	// [18] SimpleExpression2 = OP_PLUS
			Action.RETURN,	// [19] SimpleExpression2 = OP_MINUS
			Action.RETURN,	// [20] SimpleExpression3 = OP_PLUS
			Action.RETURN,	// [21] SimpleExpression3 = OP_MINUS
			Action.RETURN,	// [22] SimpleExpression3 = OP_OR
			Action.NONE,  	// [23] SimpleExpression4 = 
			RETURN3,	// [24] SimpleExpression4 = SimpleExpression3 term SimpleExpression4; returns 'SimpleExpression4' although none is marked
			Action.NONE,  	// [25] opt$expression3 = 
			Action.RETURN,	// [26] opt$expression3 = expression3
			RETURN2,	// [27] expression = SimpleExpression opt$expression3; returns 'opt$expression3' although none is marked
			Action.RETURN,	// [28] expression2 = EQUALS
			Action.RETURN,	// [29] expression2 = HASHTAG
			Action.RETURN,	// [30] expression2 = SMALLER
			Action.RETURN,	// [31] expression2 = SMALLEREQ
			Action.RETURN,	// [32] expression2 = GREATER
			Action.RETURN,	// [33] expression2 = GREATEREQ
			RETURN2,	// [34] expression3 = expression2 SimpleExpression; returns 'SimpleExpression' although none is marked
			RETURN4,	// [35] assignment = IDENTIFIER selector ASSIGN expression; returns 'expression' although none is marked
			Action.NONE,  	// [36] opt$ActualParameters3 = 
			Action.RETURN,	// [37] opt$ActualParameters3 = ActualParameters3
			RETURN3,	// [38] ActualParameters = LPAREN opt$ActualParameters3 RPAREN; returns 'RPAREN' although none is marked
			Action.NONE,  	// [39] ActualParameters2 = 
			RETURN3,	// [40] ActualParameters2 = COMMA expression ActualParameters2; returns 'ActualParameters2' although none is marked
			RETURN2,	// [41] ActualParameters3 = expression ActualParameters2; returns 'ActualParameters2' although none is marked
			Action.NONE,  	// [42] opt$ActualParameters = 
			Action.RETURN,	// [43] opt$ActualParameters = ActualParameters
			RETURN3,	// [44] ProcedureCall = IDENTIFIER selector opt$ActualParameters; returns 'opt$ActualParameters' although none is marked
			Action.NONE,  	// [45] opt$IfStatement3 = 
			Action.RETURN,	// [46] opt$IfStatement3 = IfStatement3
			RETURN7,	// [47] IfStatement = IF expression THEN StatementSequence IfStatement2 opt$IfStatement3 END; returns 'END' although none is marked
			Action.NONE,  	// [48] IfStatement2 = 
			RETURN5,	// [49] IfStatement2 = ELSEIF expression THEN StatementSequence IfStatement2; returns 'IfStatement2' although none is marked
			RETURN2,	// [50] IfStatement3 = ELSE StatementSequence; returns 'StatementSequence' although none is marked
			RETURN5,	// [51] WhileStatement = WHILE expression DO StatementSequence END; returns 'END' although none is marked
			Action.NONE,  	// [52] opt$statement2 = 
			Action.RETURN,	// [53] opt$statement2 = statement2
			Action.RETURN,	// [54] statement = opt$statement2
			Action.RETURN,	// [55] statement2 = assignment
			Action.RETURN,	// [56] statement2 = ProcedureCall
			Action.RETURN,	// [57] statement2 = IfStatement
			Action.RETURN,	// [58] statement2 = WhileStatement
			RETURN2,	// [59] StatementSequence = statement StatementSequence2; returns 'StatementSequence2' although none is marked
			Action.NONE,  	// [60] StatementSequence2 = 
			RETURN3,	// [61] StatementSequence2 = SEMICOLON statement StatementSequence2; returns 'StatementSequence2' although none is marked
			RETURN2,	// [62] IdentList = IDENTIFIER IdentList2; returns 'IdentList2' although none is marked
			Action.NONE,  	// [63] IdentList2 = 
			RETURN3,	// [64] IdentList2 = COMMA IDENTIFIER IdentList2; returns 'IdentList2' although none is marked
			RETURN4,	// [65] ArrayType = ARRAY expression OF type; returns 'type' although none is marked
			Action.NONE,  	// [66] opt$FieldList2 = 
			Action.RETURN,	// [67] opt$FieldList2 = FieldList2
			Action.RETURN,	// [68] FieldList = opt$FieldList2
			RETURN3,	// [69] FieldList2 = IdentList COLON type; returns 'type' although none is marked
			RETURN4,	// [70] RecordType = RECORD FieldList RecordType2 END; returns 'END' although none is marked
			Action.NONE,  	// [71] RecordType2 = 
			RETURN3,	// [72] RecordType2 = SEMICOLON FieldList RecordType2; returns 'RecordType2' although none is marked
			Action.RETURN,	// [73] type = IDENTIFIER
			Action.RETURN,	// [74] type = ArrayType
			Action.RETURN,	// [75] type = RecordType
			Action.NONE,  	// [76] opt$VAR = 
			Action.RETURN,	// [77] opt$VAR = VAR
			RETURN4,	// [78] FPSection = opt$VAR IdentList COLON type; returns 'type' although none is marked
			Action.NONE,  	// [79] opt$FormalParameters3 = 
			Action.RETURN,	// [80] opt$FormalParameters3 = FormalParameters3
			RETURN3,	// [81] FormalParameters = LPAREN opt$FormalParameters3 RPAREN; returns 'RPAREN' although none is marked
			Action.NONE,  	// [82] FormalParameters2 = 
			RETURN3,	// [83] FormalParameters2 = SEMICOLON FPSection FormalParameters2; returns 'FormalParameters2' although none is marked
			RETURN2,	// [84] FormalParameters3 = FPSection FormalParameters2; returns 'FormalParameters2' although none is marked
			Action.NONE,  	// [85] opt$FormalParameters = 
			Action.RETURN,	// [86] opt$FormalParameters = FormalParameters
			RETURN3,	// [87] ProcedureHeading = PROCEDURE IDENTIFIER opt$FormalParameters; returns 'opt$FormalParameters' although none is marked
			Action.NONE,  	// [88] opt$ProcedureBody2 = 
			Action.RETURN,	// [89] opt$ProcedureBody2 = ProcedureBody2
			RETURN4,	// [90] ProcedureBody = declarations opt$ProcedureBody2 END IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [91] ProcedureBody2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
			RETURN3,	// [92] ProcedureDeclaration = ProcedureHeading SEMICOLON ProcedureBody; returns 'ProcedureBody' although none is marked
			Action.NONE,  	// [93] opt$declarations3 = 
			Action.RETURN,	// [94] opt$declarations3 = declarations3
			Action.NONE,  	// [95] opt$declarations5 = 
			Action.RETURN,	// [96] opt$declarations5 = declarations5
			Action.NONE,  	// [97] opt$declarations7 = 
			Action.RETURN,	// [98] opt$declarations7 = declarations7
			RETURN4,	// [99] declarations = opt$declarations3 opt$declarations5 opt$declarations7 declarations8; returns 'declarations8' although none is marked
			Action.NONE,  	// [100] declarations2 = 
			RETURN5,	// [101] declarations2 = IDENTIFIER EQUALS expression SEMICOLON declarations2; returns 'declarations2' although none is marked
			RETURN2,	// [102] declarations3 = CONST declarations2; returns 'declarations2' although none is marked
			Action.NONE,  	// [103] declarations4 = 
			RETURN5,	// [104] declarations4 = IDENTIFIER EQUALS type SEMICOLON declarations4; returns 'declarations4' although none is marked
			RETURN2,	// [105] declarations5 = TYPE declarations4; returns 'declarations4' although none is marked
			Action.NONE,  	// [106] declarations6 = 
			RETURN5,	// [107] declarations6 = IdentList COLON type SEMICOLON declarations6; returns 'declarations6' although none is marked
			RETURN2,	// [108] declarations7 = VAR declarations6; returns 'declarations6' although none is marked
			Action.NONE,  	// [109] declarations8 = 
			RETURN3,	// [110] declarations8 = ProcedureDeclaration SEMICOLON declarations8; returns 'declarations8' although none is marked
			Action.NONE,  	// [111] opt$module2 = 
			Action.RETURN,	// [112] opt$module2 = module2
			RETURN8,	// [113] module = MODULE IDENTIFIER SEMICOLON declarations opt$module2 END IDENTIFIER DOT; returns 'DOT' although none is marked
			RETURN2	// [114] module2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
		};

 		report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
