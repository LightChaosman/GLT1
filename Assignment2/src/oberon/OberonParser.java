package oberon;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Oberon.grammar".
 */
public class OberonParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short SEMICOLON = 2;
		static public final short END = 3;
		static public final short RPAREN = 4;
		static public final short OP_PLUS = 5;
		static public final short OP_MINUS = 6;
		static public final short IF = 7;
		static public final short WHILE = 8;
		static public final short COLON = 9;
		static public final short LPAREN = 10;
		static public final short ARRAY = 11;
		static public final short RECORD = 12;
		static public final short DOT = 13;
		static public final short COMMA = 14;
		static public final short NUMBER = 15;
		static public final short TILDE = 16;
		static public final short EQUALS = 17;
		static public final short LBRACE = 18;
		static public final short VAR = 19;
		static public final short THEN = 20;
		static public final short ELSEIF = 21;
		static public final short PROCEDURE = 22;
		static public final short OP_TIMES = 23;
		static public final short OP_DIV = 24;
		static public final short OP_MOD = 25;
		static public final short OP_AND = 26;
		static public final short OP_OR = 27;
		static public final short BEGIN = 28;
		static public final short CONST = 29;
		static public final short MODULE = 30;
		static public final short DO = 31;
		static public final short RBRACE = 32;
		static public final short ASSIGN = 33;
		static public final short OF = 34;
		static public final short HASHTAG = 35;
		static public final short SMALLER = 36;
		static public final short SMALLEREQ = 37;
		static public final short GREATER = 38;
		static public final short GREATEREQ = 39;
		static public final short ELSE = 40;
		static public final short TYPE = 41;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orbdUSLDKLntzlPfQooYA8h0KLKPH5DBAobANiiknI5dTX4HSK15IAsB4b5Ym4Em8AY29" +
		"YmOAAeWWYJIIQs3Mn5#mbqSH8Z369CJdvtZjtXiTyHlpBcS$t$SuvzznxNxdtlID5yzL2hT" +
		"LAkwgDTbDRxPpZZyxnn#Nun#VuKtByyxJBTdwrscilzTRme7lgKFr2XwchcgXK2PNQRDLee" +
		"0Pfi8QeWbY52jLT$LJbwOcVwU7yz2YzWbQIdxQEL3Vjhc6g8pyTQOpbJmWwILE3TR7c16kX" +
		"hjPIuiKw2#sEdgAZD9wPp$UQL84Er46wMRKwKsVeLkAdwYfTeQ6wGxUhdVRnsbxxCjhUwkI" +
		"oxLtrKLyLs$MCTm7CysDbADRfS8CMaHrYjafDDSyUraxCqK7xCyVrcgy5FkicRytJ$RehM0" +
		"y7TQrhitb7gCIhczjHeltKaR4ELcSuH0Tmbmxd6hkfpDxI7bnZ9XE8ZF3wYexHIJvwSeWiq" +
		"zbslxTMQQmkqqpDqkNse5Rfbzp7vPfbc$6kzNsMSPOhz2ijiRKwrXrjCtvApMokbjbrQcvp" +
		"zA1QgaXTr4Fbwgy1UaJrzeuQx0sDj3TrjCPebFr14#qb7QSJTA8cwpHDqsfDv5u#e1bsfzs" +
		"j6Jf7vzezccvtwK9TeeiqNPVgrxh6xhNxDDjMw4hDjOTikJsWk$alXXjrdMxHRVQOxj6Tkb" +
		"VtsM$i4Nk2beUqakCQFQfr71$J#kogA#MESRz#Ph#LVq9TU4OPBMOzxy5#6QU85HQnAlVd#" +
		"NNqQx4Glv2dquBxk8kdDNwcX$DpHukoLc#UqWJkQs4saY#$NzQgoLgrVbz6hBBkp1onqvgg" +
		"6JEFzEhY1UpgmQoUOzc7WuaFvubDufqnWlqvckVgD3tQUFQUoqxvOyGkYzWx4NytLWOtHyI" +
		"Es9diRJ6NcsBVrR5ogfcZ1#kubyzAMn5lduoLqMsjpYfatJbrSplAULEuiIfPZOugVvTQ#6" +
		"EAFTGwcva#voAlIVPjexT6PIDZUQUbh#W4LkqKl4BofxA6QzXJ2JN7g$KPHPnbTwuYGQzE$" +
		"jWSFq5FqPPazYJlnGHxePnOU$gLuwVu3mhq9QCDx0RxGb#y1FyI8dipUblljVNtAqqzVYki" +
		"UXZgMzqnnRmf$tVtVmXqu5oIM4arO4NXc2RXiuPvROLA6owH$tM2XLBK2rqCg#0v$DvmEFI" +
		"5FiIkGVj1$z1lZjCVWryDV0fV1V$0MDlNGQjXGR07ml8yuvG4hOUg7vbhHj1lqnhL14t0GV" +
		"dxH2ce3lqcx#XQOlEieC#Wq7#m$4EFQg49D8SZe10gQ5YDLa8H30jz6ZYiGO#4bj0JVorwL" +
		"6ZV5Tnzs8mE2R5kK0T3Wtyqr0Vx6AY22L0CnyCaE0ucal0aEZdaJWaw1dQ7gN1AY9q6UyBf" +
		"S0Q1vz5fS2QS1Vl1sR0Fi5wYS#0yE9VSTNdkRGcCnNWn#ET3AKmF$eLG1XV7#bp0OKkmEy1" +
		"5C1CE0yBH5Q7jgg0pE7o4NWspOkDS6$HI3f#Xis5kfjtCjiIUPnt#v$cUDV5NGiuNGHFvyc" +
		"9ZTOK1q3humsDjcVN9caZl6tuRd9zdd7NX$7TIsADvSfuA#dHEl6m7vzThcnsrtD6rnFeKR" +
		"Uz7JKBSlGUQ1Tll1#xNEyJQO6wCzo7#SSYh2$wNiV4RGkmR#hOBiOsm2KR4ycR6xCpxPrFk" +
		"#JBEzx5pRHVhqnXYxMEnzJ6x8kSwEuRu9swzXrXbY2t9dPVVcA1BWuvqxyvO#sYtr$FqMnR" +
		"6BetDNPQJyqFCNXvoKh7yobZxoX2h3lu6XPyjLUndBy1JzbjxmPwqv#nvUzQUiQVjTzp1rs" +
		"shRR7FxLFx3EizylvaV$N7FzgVxKlxmhwpV#9$P$#mR#tlzetzZLx$WVyH$QzjvVY3VMrVs" +
		"L$iU#$z6$vbdzZ7zf5zQ1$O#$QglUPRtWvdipLpTEVbxT#7SmmnUp5hlMotswqstsx1dc$p" +
		"ybxP7N1pTjp5#ecVhRGrzgYj3lcRx76lwu9ki8rUrs$NPuajj0N1NcWts6sso6uC$YAx2Pa" +
		"czzNimnUtjoT99P3mLK5viAkWFpdzyIk9n#bCl3DwC6rTK4Tr3FUc6K0RAmiYwhm4bLgKb$" +
		"6qTQLEuAi04PLTaag4dOjEe8sl24JKjAus4aHKjqsfJ0geXnBKkGNKl8A8#ZUY0jwUCb$li" +
		"0jGLmkvhrm3O$LaJhvq455NHjIHIIgv51MAV9NImrTwQLorK8FMqiuN328giIILZY19HPgW" +
		"BXD4L92kOXD4rAmfghG4zMJIlPLyfTk8DgAZq56#marHFHImAnE#yXc6FHNRVMa7OhiApts" +
		"nAnXZ73hEr#tDgDGJElN$Z$MK60==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};
 

	public final static class Events extends Parser.Events{
		public void syntaxError(Symbol token){
			throw new RuntimeException(token.value.toString());
		}
	}

	private final Action[] actions;

	public OberonParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.NONE,  	// [0] selector = 
			RETURN2,	// [1] selector = selector2 selector; returns 'selector' although none is marked
			RETURN2,	// [2] selector2 = DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [3] selector2 = LBRACE expression RBRACE; returns 'RBRACE' although none is marked
			RETURN2,	// [4] factor = IDENTIFIER selector; returns 'selector' although none is marked
			Action.RETURN,	// [5] factor = NUMBER
			RETURN3,	// [6] factor = LPAREN expression RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [7] factor = TILDE factor; returns 'factor' although none is marked
			RETURN2,	// [8] term = factor term2; returns 'term2' although none is marked
			Action.NONE,  	// [9] term2 = 
			RETURN3,	// [10] term2 = term3 factor term2; returns 'term2' although none is marked
			Action.RETURN,	// [11] term3 = OP_TIMES
			Action.RETURN,	// [12] term3 = OP_DIV
			Action.RETURN,	// [13] term3 = OP_MOD
			Action.RETURN,	// [14] term3 = OP_AND
			Action.NONE,  	// [15] opt$SimpleExpression2 = 
			Action.RETURN,	// [16] opt$SimpleExpression2 = SimpleExpression2
			RETURN3,	// [17] SimpleExpression = opt$SimpleExpression2 term SimpleExpression4; returns 'SimpleExpression4' although none is marked
			Action.RETURN,	// [18] SimpleExpression2 = OP_PLUS
			Action.RETURN,	// [19] SimpleExpression2 = OP_MINUS
			Action.RETURN,	// [20] SimpleExpression3 = OP_PLUS
			Action.RETURN,	// [21] SimpleExpression3 = OP_MINUS
			Action.RETURN,	// [22] SimpleExpression3 = OP_OR
			Action.NONE,  	// [23] SimpleExpression4 = 
			RETURN3,	// [24] SimpleExpression4 = SimpleExpression3 term SimpleExpression4; returns 'SimpleExpression4' although none is marked
			Action.NONE,  	// [25] opt$expression3 = 
			Action.RETURN,	// [26] opt$expression3 = expression3
			RETURN2,	// [27] expression = SimpleExpression opt$expression3; returns 'opt$expression3' although none is marked
			Action.RETURN,	// [28] expression2 = EQUALS
			Action.RETURN,	// [29] expression2 = HASHTAG
			Action.RETURN,	// [30] expression2 = SMALLER
			Action.RETURN,	// [31] expression2 = SMALLEREQ
			Action.RETURN,	// [32] expression2 = GREATER
			Action.RETURN,	// [33] expression2 = GREATEREQ
			RETURN2,	// [34] expression3 = expression2 SimpleExpression; returns 'SimpleExpression' although none is marked
			RETURN4,	// [35] assignment = IDENTIFIER selector ASSIGN expression; returns 'expression' although none is marked
			Action.NONE,  	// [36] opt$ActualParameters3 = 
			Action.RETURN,	// [37] opt$ActualParameters3 = ActualParameters3
			RETURN3,	// [38] ActualParameters = LPAREN opt$ActualParameters3 RPAREN; returns 'RPAREN' although none is marked
			Action.NONE,  	// [39] ActualParameters2 = 
			RETURN3,	// [40] ActualParameters2 = COMMA expression ActualParameters2; returns 'ActualParameters2' although none is marked
			RETURN2,	// [41] ActualParameters3 = expression ActualParameters2; returns 'ActualParameters2' although none is marked
			Action.NONE,  	// [42] opt$ActualParameters = 
			Action.RETURN,	// [43] opt$ActualParameters = ActualParameters
			RETURN3,	// [44] ProcedureCall = IDENTIFIER selector opt$ActualParameters; returns 'opt$ActualParameters' although none is marked
			Action.NONE,  	// [45] opt$IfStatement3 = 
			Action.RETURN,	// [46] opt$IfStatement3 = IfStatement3
			RETURN7,	// [47] IfStatement = IF expression THEN StatementSequence IfStatement2 opt$IfStatement3 END; returns 'END' although none is marked
			RETURN5,	// [48] IfStatement2 = ELSEIF expression THEN StatementSequence IfStatement2; returns 'IfStatement2' although none is marked
			RETURN2,	// [49] IfStatement3 = ELSE StatementSequence; returns 'StatementSequence' although none is marked
			RETURN5,	// [50] WhileStatement = WHILE expression DO StatementSequence END; returns 'END' although none is marked
			Action.NONE,  	// [51] opt$statement2 = 
			Action.RETURN,	// [52] opt$statement2 = statement2
			Action.RETURN,	// [53] statement = opt$statement2
			Action.RETURN,	// [54] statement2 = assignment
			Action.RETURN,	// [55] statement2 = ProcedureCall
			Action.RETURN,	// [56] statement2 = IfStatement
			Action.RETURN,	// [57] statement2 = WhileStatement
			RETURN2,	// [58] StatementSequence = statement StatementSequence2; returns 'StatementSequence2' although none is marked
			Action.NONE,  	// [59] StatementSequence2 = 
			RETURN2,	// [60] StatementSequence2 = SEMICOLON statement; returns 'statement' although none is marked
			RETURN2,	// [61] IdentList = IDENTIFIER IdentList2; returns 'IdentList2' although none is marked
			Action.NONE,  	// [62] IdentList2 = 
			RETURN3,	// [63] IdentList2 = COMMA IDENTIFIER IdentList2; returns 'IdentList2' although none is marked
			RETURN4,	// [64] ArrayType = ARRAY expression OF type; returns 'type' although none is marked
			Action.NONE,  	// [65] opt$FieldList2 = 
			Action.RETURN,	// [66] opt$FieldList2 = FieldList2
			Action.RETURN,	// [67] FieldList = opt$FieldList2
			RETURN3,	// [68] FieldList2 = IdentList COLON type; returns 'type' although none is marked
			RETURN4,	// [69] RecordType = RECORD FieldList RecordType2 END; returns 'END' although none is marked
			Action.NONE,  	// [70] RecordType2 = 
			RETURN3,	// [71] RecordType2 = SEMICOLON FieldList RecordType2; returns 'RecordType2' although none is marked
			Action.RETURN,	// [72] type = IDENTIFIER
			Action.RETURN,	// [73] type = ArrayType
			Action.RETURN,	// [74] type = RecordType
			Action.NONE,  	// [75] opt$VAR = 
			Action.RETURN,	// [76] opt$VAR = VAR
			RETURN4,	// [77] FPSection = opt$VAR IdentList COLON type; returns 'type' although none is marked
			Action.NONE,  	// [78] opt$FormalParameters3 = 
			Action.RETURN,	// [79] opt$FormalParameters3 = FormalParameters3
			RETURN3,	// [80] FormalParameters = LPAREN opt$FormalParameters3 RPAREN; returns 'RPAREN' although none is marked
			Action.NONE,  	// [81] FormalParameters2 = 
			RETURN3,	// [82] FormalParameters2 = SEMICOLON FPSection FormalParameters2; returns 'FormalParameters2' although none is marked
			RETURN2,	// [83] FormalParameters3 = FPSection FormalParameters2; returns 'FormalParameters2' although none is marked
			Action.NONE,  	// [84] opt$FormalParameters = 
			Action.RETURN,	// [85] opt$FormalParameters = FormalParameters
			RETURN3,	// [86] ProcedureHeading = PROCEDURE IDENTIFIER opt$FormalParameters; returns 'opt$FormalParameters' although none is marked
			Action.NONE,  	// [87] opt$ProcedureBody2 = 
			Action.RETURN,	// [88] opt$ProcedureBody2 = ProcedureBody2
			RETURN4,	// [89] ProcedureBody = declarations opt$ProcedureBody2 END IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [90] ProcedureBody2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
			RETURN3,	// [91] ProcedureDeclaration = ProcedureHeading SEMICOLON ProcedureBody; returns 'ProcedureBody' although none is marked
			Action.NONE,  	// [92] opt$declarations3 = 
			Action.RETURN,	// [93] opt$declarations3 = declarations3
			Action.NONE,  	// [94] opt$declarations5 = 
			Action.RETURN,	// [95] opt$declarations5 = declarations5
			Action.NONE,  	// [96] opt$declarations7 = 
			Action.RETURN,	// [97] opt$declarations7 = declarations7
			RETURN4,	// [98] declarations = opt$declarations3 opt$declarations5 opt$declarations7 declarations8; returns 'declarations8' although none is marked
			RETURN5,	// [99] declarations2 = IDENTIFIER EQUALS expression SEMICOLON declarations2; returns 'declarations2' although none is marked
			RETURN2,	// [100] declarations3 = CONST declarations2; returns 'declarations2' although none is marked
			Action.NONE,  	// [101] declarations4 = 
			RETURN5,	// [102] declarations4 = IDENTIFIER EQUALS type SEMICOLON declarations4; returns 'declarations4' although none is marked
			RETURN2,	// [103] declarations5 = TYPE declarations4; returns 'declarations4' although none is marked
			Action.NONE,  	// [104] declarations6 = 
			RETURN5,	// [105] declarations6 = IdentList COLON type SEMICOLON declarations6; returns 'declarations6' although none is marked
			RETURN2,	// [106] declarations7 = VAR declarations6; returns 'declarations6' although none is marked
			Action.NONE,  	// [107] declarations8 = 
			RETURN3,	// [108] declarations8 = ProcedureDeclaration SEMICOLON declarations8; returns 'declarations8' although none is marked
			Action.NONE,  	// [109] opt$module2 = 
			Action.RETURN,	// [110] opt$module2 = module2
			RETURN8,	// [111] module = MODULE IDENTIFIER SEMICOLON declarations opt$module2 END IDENTIFIER DOT; returns 'DOT' although none is marked
			RETURN2	// [112] module2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
		};

 report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
