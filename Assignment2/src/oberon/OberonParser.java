package oberon;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Oberon.grammar".
 */
public class OberonParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short SEMICOLON = 2;
		static public final short END = 3;
		static public final short RPAREN = 4;
		static public final short OP_PLUS = 5;
		static public final short OP_MINUS = 6;
		static public final short IF = 7;
		static public final short WHILE = 8;
		static public final short COLON = 9;
		static public final short LPAREN = 10;
		static public final short ARRAY = 11;
		static public final short RECORD = 12;
		static public final short DOT = 13;
		static public final short COMMA = 14;
		static public final short NUMBER = 15;
		static public final short TILDE = 16;
		static public final short EQUALS = 17;
		static public final short LBRACE = 18;
		static public final short VAR = 19;
		static public final short THEN = 20;
		static public final short ELSEIF = 21;
		static public final short PROCEDURE = 22;
		static public final short OP_TIMES = 23;
		static public final short OP_DIV = 24;
		static public final short OP_MOD = 25;
		static public final short OP_AND = 26;
		static public final short OP_OR = 27;
		static public final short BEGIN = 28;
		static public final short CONST = 29;
		static public final short MODULE = 30;
		static public final short DO = 31;
		static public final short RBRACE = 32;
		static public final short ASSIGN = 33;
		static public final short OF = 34;
		static public final short HASHTAG = 35;
		static public final short SMALLER = 36;
		static public final short SMALLEREQ = 37;
		static public final short GREATER = 38;
		static public final short GREATEREQ = 39;
		static public final short ELSE = 40;
		static public final short TYPE = 41;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orbdUSLDKLntzlPcYhB4LarQ0YYh98egmiPIcxBBkKnLrOn0K50PKI4YlsWWL95ANfKaG" +
		"H2nPK54KGQI6eYOabnNH3YhqhzkxnU#$S6Hxp6SbVcVbyt##SSy#zzvLxtpjIj4WjrLPjj8" +
		"$QQL#rrzuv$jWSVqAEVqgEFot7lqYjT$Ehr54$K5#D37g0VgIZTBIwgwbAb529pLEr1ck8X" +
		"cgOoecLgq0zDK2LdjxucHxEJu$I9sW5#MdhEFNGVXgXMlBJaOPO$gIWKpGzM9ThGR2Mwbgj" +
		"95waSz2Uw6awNXEP#MAlIJNHuJf2Dwj6CtIMRYL#kkReQWtN7RfT7NIGruuwcD4EL1UNRVz" +
		"KF$LNaLtFU9T0enyhGv7EX2MwYUmGitLgfaPxM7inHoSToXmtQ94M#wnbtchK$RehM0y7TQ" +
		"qRitd7gjYhczjHh4FKcR6EL5VueGxZBXt3DVPGgVrT#tEDcKmWCihhypfHF$7HduR8Afrhz" +
		"tjhdSRhPvgjkVgvFQXrke3xk5fpRJlUFDzd5MUvHXTgXMtKIUves$5JQcuBjCeMgeNDruDg" +
		"fK9rKo#LQQ06wH7LsGkgjxzgjFrD9sYSnjWVDTb#fvDrgdwigJf3Pskz9dCl7z0ikzFkrYo" +
		"Tf$Fj7isqktIfhj1bcgahTPMkitljFistDRf62#qXMsqFw6x#o#56NQzRT9izfdjqf#xLVV" +
		"QuFMA$fEKXhUMuGOzg4yV7j3cxwaguOzol$xFVnZ#XRZoZZ1QndlTdlqnGn0gBM9M7ylmw#" +
		"xLOW5$0qsd9VMpjQOkVwU7ytD6YhDMNfpI9#rgGZUJB7v2rghDMZT#N4Qki9pD7xBHcQixC" +
		"exswU1DszL1Mpqdimw74H$B4fl3E6CN#7CjpTPeURI9xpsMd$35YbqNidOY$6ok3coDYH#n" +
		"DzgwOoqsnxsfPELNCqOjrtCTdfQs8jq$6okYkLcSLiEwSkhaTPRmft5WLh4P7fRzBBVqnnH" +
		"vgcyrCdtEXroJxji5ROxAHyRpJqbTqAgjs6bu1#TDPmzNigOHQuDNuZ4BEiYTNaQ1N5tziW" +
		"P#WfsXBCdkIzsA2lL16h2Fzol1J$8S4#fFH3lQ5Ww4$Ne9$CP436Rszzzhx#vMc3hyDLXqC" +
		"zwtkc6BUbF#x#pyCEd4kIQoawh6YS4oJy5aZlBP1fIrNoF#wm58fweCkXtNmD7vVE0RwGpz" +
		"Yrw43O63ejy3fzy6l6bw1TuD$UApj$Q1Li3ZOWs5rdd6AWzP1vVVCDIlenscDgeCcu8ZyVQ" +
		"8KL8L#K$TqBR5vrj1dIEW$LFwXHpNG55h0iL00vJIiHokW44Q4FlKSDg37GIleZRyHFJwqx" +
		"mFkFcn7XuLO3wY5uS4$0Ug2VI9KmYGeWbDW2fmCaqbu0fqQSgS57GVxmNGuBSJEW0FWJ3YB" +
		"m3FesJ03pe53u5mu25WlqNbm4PnFxgOyzxOOncCy5$oBeGHc1lzIA8NBOtqkuR0Zs9tWCfW" +
		"DHmFXwEhGDYVeB0ulejV2tDWuyu9UoU5LT3uipBIRsOxOywp5VotVioR#VCXvCsWYNrvihE" +
		"um2De6VsIiBRC#MHFfVSDlY$FpZBCfdFzU2diqJywJGP$AYPVkuVpwxBAZLdkwbbYVmjtzg" +
		"6c8k$T0ys3x$S3zUe5OEyojyJx4NmfvjS5$ApP#VOXzIDyE8ROLji6eMDxic9rv$spBFL$6" +
		"#J9shXrYVHf2h6CijZbcb#TSP#SGVzcjzn2h2B4LkVFo6nTqPT3HxjqPQn$hzdgUVgl2s2M" +
		"nkKjpShwEsQj3JYgMNn5hNnjYLS7Vel2pbOhzx5buqdvbpzeJzhGzOx#rtzXJzclku5zif#" +
		"smr#mLUnNhN#IzOU$vu#lsjhrbRzgdzXd#f$Q9VMmVsOVs0Rs#Wc#9VcCxENvjxzkxzevzw" +
		"Rqlu7DxsLwo5#s$zX$xj$t9$knR$X7EPcVcwCxBsty8vnXYzbpM#htTRhTQezs2tMWtvBso" +
		"EsovtHHwBxURzJz#jjOssAEsFfp7Dlk5rqr1jzXMhvjtwxF2bjYYO2#nnNQRBREbmLzcDo8" +
		"pvBwQ$VZYzlKagGGIlYee2tOb32Hd87u5yJXTYNT5ZwIj6#geYk7UD8DeOsL1H9sNe5AByZ" +
		"AHjkxK2NmL8AAoIrA9i7FHIRJn5O68cjRLHeA8whOPbKaJwg44TMuJQbv1HFqRKG7lJgclT" +
		"zW5gAk5t5Ukdh5wCoTVEeYeAoFgo2ILN8eAHRvAwUKhlJIkMgX6QsZd2mOHbLYIIaUGf29D" +
		"K9S98Yf8Lx498chM55LQWdeowTvAlj9jG1lGCUWON#6cVFLGntMC9jTLFoEmfsExh#rWR5V" +
		"bkQzsEUDCG2VushqvrNf2fty7tIUNYm==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};
 

	public final static class Events extends Parser.Events{
		public void syntaxError(Symbol token){
			throw new RuntimeException(token.value.toString());
		}
	}

	private final Action[] actions;

	public OberonParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.NONE,  	// [0] selector = 
			RETURN2,	// [1] selector = selector2 selector; returns 'selector' although none is marked
			RETURN2,	// [2] selector2 = DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [3] selector2 = LBRACE expression RBRACE; returns 'RBRACE' although none is marked
			RETURN2,	// [4] factor = IDENTIFIER selector; returns 'selector' although none is marked
			Action.RETURN,	// [5] factor = NUMBER
			RETURN3,	// [6] factor = LPAREN expression RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [7] factor = TILDE factor; returns 'factor' although none is marked
			RETURN2,	// [8] term = factor term2; returns 'term2' although none is marked
			Action.NONE,  	// [9] term2 = 
			RETURN3,	// [10] term2 = term3 factor term2; returns 'term2' although none is marked
			Action.RETURN,	// [11] term3 = OP_TIMES
			Action.RETURN,	// [12] term3 = OP_DIV
			Action.RETURN,	// [13] term3 = OP_MOD
			Action.RETURN,	// [14] term3 = OP_AND
			Action.NONE,  	// [15] opt$SimpleExpression2 = 
			Action.RETURN,	// [16] opt$SimpleExpression2 = SimpleExpression2
			RETURN3,	// [17] SimpleExpression = opt$SimpleExpression2 term SimpleExpression4; returns 'SimpleExpression4' although none is marked
			Action.RETURN,	// [18] SimpleExpression2 = OP_PLUS
			Action.RETURN,	// [19] SimpleExpression2 = OP_MINUS
			Action.RETURN,	// [20] SimpleExpression3 = OP_PLUS
			Action.RETURN,	// [21] SimpleExpression3 = OP_MINUS
			Action.RETURN,	// [22] SimpleExpression3 = OP_OR
			Action.NONE,  	// [23] SimpleExpression4 = 
			RETURN3,	// [24] SimpleExpression4 = SimpleExpression3 term SimpleExpression4; returns 'SimpleExpression4' although none is marked
			Action.NONE,  	// [25] opt$expression3 = 
			Action.RETURN,	// [26] opt$expression3 = expression3
			RETURN2,	// [27] expression = SimpleExpression opt$expression3; returns 'opt$expression3' although none is marked
			Action.RETURN,	// [28] expression2 = EQUALS
			Action.RETURN,	// [29] expression2 = HASHTAG
			Action.RETURN,	// [30] expression2 = SMALLER
			Action.RETURN,	// [31] expression2 = SMALLEREQ
			Action.RETURN,	// [32] expression2 = GREATER
			Action.RETURN,	// [33] expression2 = GREATEREQ
			RETURN2,	// [34] expression3 = expression2 SimpleExpression; returns 'SimpleExpression' although none is marked
			RETURN4,	// [35] assignment = IDENTIFIER selector ASSIGN expression; returns 'expression' although none is marked
			Action.NONE,  	// [36] opt$ActualParameters3 = 
			Action.RETURN,	// [37] opt$ActualParameters3 = ActualParameters3
			RETURN3,	// [38] ActualParameters = LPAREN opt$ActualParameters3 RPAREN; returns 'RPAREN' although none is marked
			Action.NONE,  	// [39] ActualParameters2 = 
			RETURN3,	// [40] ActualParameters2 = COMMA expression ActualParameters2; returns 'ActualParameters2' although none is marked
			RETURN2,	// [41] ActualParameters3 = expression ActualParameters2; returns 'ActualParameters2' although none is marked
			Action.NONE,  	// [42] opt$ActualParameters = 
			Action.RETURN,	// [43] opt$ActualParameters = ActualParameters
			RETURN3,	// [44] ProcedureCall = IDENTIFIER selector opt$ActualParameters; returns 'opt$ActualParameters' although none is marked
			Action.NONE,  	// [45] opt$IfStatement3 = 
			Action.RETURN,	// [46] opt$IfStatement3 = IfStatement3
			RETURN7,	// [47] IfStatement = IF expression THEN StatementSequence IfStatement2 opt$IfStatement3 END; returns 'END' although none is marked
			RETURN5,	// [48] IfStatement2 = ELSEIF expression THEN StatementSequence IfStatement2; returns 'IfStatement2' although none is marked
			RETURN2,	// [49] IfStatement3 = ELSE StatementSequence; returns 'StatementSequence' although none is marked
			RETURN5,	// [50] WhileStatement = WHILE expression DO StatementSequence END; returns 'END' although none is marked
			Action.NONE,  	// [51] opt$statement2 = 
			Action.RETURN,	// [52] opt$statement2 = statement2
			Action.RETURN,	// [53] statement = opt$statement2
			Action.RETURN,	// [54] statement2 = assignment
			Action.RETURN,	// [55] statement2 = ProcedureCall
			Action.RETURN,	// [56] statement2 = IfStatement
			Action.RETURN,	// [57] statement2 = WhileStatement
			RETURN2,	// [58] StatementSequence = statement StatementSequence2; returns 'StatementSequence2' although none is marked
			Action.NONE,  	// [59] StatementSequence2 = 
			RETURN2,	// [60] StatementSequence2 = SEMICOLON statement; returns 'statement' although none is marked
			RETURN2,	// [61] IdentList = IDENTIFIER IdentList2; returns 'IdentList2' although none is marked
			Action.NONE,  	// [62] IdentList2 = 
			RETURN3,	// [63] IdentList2 = COMMA IDENTIFIER IdentList2; returns 'IdentList2' although none is marked
			RETURN4,	// [64] ArrayType = ARRAY expression OF type; returns 'type' although none is marked
			Action.NONE,  	// [65] opt$FieldList2 = 
			Action.RETURN,	// [66] opt$FieldList2 = FieldList2
			Action.RETURN,	// [67] FieldList = opt$FieldList2
			RETURN3,	// [68] FieldList2 = IdentList COLON type; returns 'type' although none is marked
			RETURN4,	// [69] RecordType = RECORD FieldList RecordType2 END; returns 'END' although none is marked
			Action.NONE,  	// [70] RecordType2 = 
			RETURN3,	// [71] RecordType2 = SEMICOLON FieldList RecordType2; returns 'RecordType2' although none is marked
			Action.RETURN,	// [72] type = IDENTIFIER
			Action.RETURN,	// [73] type = ArrayType
			Action.RETURN,	// [74] type = RecordType
			Action.NONE,  	// [75] opt$VAR = 
			Action.RETURN,	// [76] opt$VAR = VAR
			RETURN4,	// [77] FPSection = opt$VAR IdentList COLON type; returns 'type' although none is marked
			Action.NONE,  	// [78] opt$FormalParameters3 = 
			Action.RETURN,	// [79] opt$FormalParameters3 = FormalParameters3
			RETURN3,	// [80] FormalParameters = LPAREN opt$FormalParameters3 RPAREN; returns 'RPAREN' although none is marked
			Action.NONE,  	// [81] FormalParameters2 = 
			RETURN3,	// [82] FormalParameters2 = SEMICOLON FPSection FormalParameters2; returns 'FormalParameters2' although none is marked
			RETURN2,	// [83] FormalParameters3 = FPSection FormalParameters2; returns 'FormalParameters2' although none is marked
			Action.NONE,  	// [84] opt$FormalParameters = 
			Action.RETURN,	// [85] opt$FormalParameters = FormalParameters
			RETURN3,	// [86] ProcedureHeading = PROCEDURE IDENTIFIER opt$FormalParameters; returns 'opt$FormalParameters' although none is marked
			Action.NONE,  	// [87] opt$ProcedureBody2 = 
			Action.RETURN,	// [88] opt$ProcedureBody2 = ProcedureBody2
			RETURN4,	// [89] ProcedureBody = declarations opt$ProcedureBody2 END IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN2,	// [90] ProcedureBody2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
			RETURN3,	// [91] ProcedureDeclaration = ProcedureHeading SEMICOLON ProcedureBody; returns 'ProcedureBody' although none is marked
			Action.NONE,  	// [92] opt$declarations3 = 
			Action.RETURN,	// [93] opt$declarations3 = declarations3
			Action.NONE,  	// [94] opt$declarations5 = 
			Action.RETURN,	// [95] opt$declarations5 = declarations5
			Action.NONE,  	// [96] opt$declarations7 = 
			Action.RETURN,	// [97] opt$declarations7 = declarations7
			RETURN4,	// [98] declarations = opt$declarations3 opt$declarations5 opt$declarations7 declarations8; returns 'declarations8' although none is marked
			Action.NONE,  	// [99] declarations2 = 
			RETURN5,	// [100] declarations2 = IDENTIFIER EQUALS expression SEMICOLON declarations2; returns 'declarations2' although none is marked
			RETURN2,	// [101] declarations3 = CONST declarations2; returns 'declarations2' although none is marked
			Action.NONE,  	// [102] declarations4 = 
			RETURN5,	// [103] declarations4 = IDENTIFIER EQUALS type SEMICOLON declarations4; returns 'declarations4' although none is marked
			RETURN2,	// [104] declarations5 = TYPE declarations4; returns 'declarations4' although none is marked
			Action.NONE,  	// [105] declarations6 = 
			RETURN5,	// [106] declarations6 = IdentList COLON type SEMICOLON declarations6; returns 'declarations6' although none is marked
			RETURN2,	// [107] declarations7 = VAR declarations6; returns 'declarations6' although none is marked
			Action.NONE,  	// [108] declarations8 = 
			RETURN3,	// [109] declarations8 = ProcedureDeclaration SEMICOLON declarations8; returns 'declarations8' although none is marked
			Action.NONE,  	// [110] opt$module2 = 
			Action.RETURN,	// [111] opt$module2 = module2
			RETURN8,	// [112] module = MODULE IDENTIFIER SEMICOLON declarations opt$module2 END IDENTIFIER DOT; returns 'DOT' although none is marked
			RETURN2	// [113] module2 = BEGIN StatementSequence; returns 'StatementSequence' although none is marked
		};

 		report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
