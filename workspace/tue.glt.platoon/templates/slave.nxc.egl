[% // File template for generating slave.nxc
%]
/**
 * Generated file from autoconnect.egl
 * This file contains the NXC code for a following platoon vehicle
 */

#ifndef __AUTOCONNECT_LIB__NXC
#define __AUTOCONNECT_LIB__NXC

// The master tries to connect to the slave "name".
void ConnectNXT(const string name, byte channel)
{
	CommBTConnectionType args;
	args.Name = name;
	args.ConnectionSlot = channel;
	args.Action = TRUE;
	
	if(!BluetoothStatus(channel) == NO_ERR)
	{
		SysCommBTConnection(args); // try to connect.
		Wait(5000); // let the connection get created
	}
}

#endif

// Bluetooth constants
#define BT_CONN 1
#define BT_INBOX 1
#define BT_OUTBOX 5

// Motor constants
#define MOTOR_CASUAL 33 // speed for casual following
#define MOTOR_HURRY 66 // speed for catching up small delays
#define MOTOR_PANIC 100 // speed for catching up as fast as possible
#define MOTOR_TURN_TIME 1500
#define MOTOR_L OUT_A
#define MOTOR_R OUT_B
#define MOTOR_RL OUT_AB 

[%
	var cs = platoon.constraints.list;// extract headway information.
	var c;
	for(c2 in cs)
	{
		c = c2; // hacky way to extract first and only contraint: headway
	}
	var lb = c.lowbound;
	var ub = c.upbound;
	var steps = platoon.routes.steps;
	var commax = steps.size();
%]

//headway information
#define DIST_MIN [%=lb%]
#define DIST_MAX [%=ub%]
#define DIST_RANGE [%=ub-lb%]
#define DIST_HURRY [%=lb+(ub-lb)/3%] // if further away than this, hurry up
#define DIST_PANIC [%=lb+2*(ub-lb)/3%] // if further away than this, panic, full throtle

#define COM_MAX [%=commax%]

string commands[]; //The list of commands to be executed
int curCommand; //the index of the current command
int lastCommand; //the index of first empty spot in the commands array

task main() {
	ArrayInit(commands, "", COM_MAX);
	curCommand = 0;
	lastCommand = 0;
	
	string in;
	ConnectNXT(?, ?);//Connect to slave
		
	do {
		// Wait for commands from master
		ReceiveRemoteString(BT_INBOX, true, in);
		
		if(//TODO: Check if time is set){
			time = //TODO: get from string
		} else {
			time = MOTOR_TURN_TIME;
		}

		char command = //TODO: parse from `in`
		
		boolean stopped = true;
		int t = 0;
		
		do{
			
			
			double dist = Sensor(SENSOR_DISTANCE);
			double frac;
			if (Sensor(SENSOR_DISTANCE) >= [%=lb%]
				 && Sensor(SENSOR_DISTANCE) <= [%=ub%]) {
				if(stopped){
					execute(command, dist);
					stopped = false;
				}
			} else {
				if(!stopped){
					Off(MOTOR_RL);
					stopped = true;
				}
			}
			wait(5);
			t += 5;
		}while(t < time);
		
		// Done executing command
		Off(MOTOR_RL);
		
	} while(true);
}

sub execute(char command){
	int time;
	switch(command){
		case 'f':
			OnFwd(MOTOR_RL, MOTOR_POWER);
			break;
		case 'b':
			OnRev(MOTOR_RL, MOTOR_POWER);
			break;
		case 'l':
			OnFwd(MOTOR_R, MOTOR_POWER); OnRev(MOTOR_L, MOTOR_POWER);
			break;
		case 'r':
			OnFwd(MOTOR_L, MOTOR_POWER); OnRev(MOTOR_R, MOTOR_POWER);
			break;
		default:
			break;
	}
}
